# 第一章 JAVA架构师
- ## 03-性能调优
------
## 目录
- [第一章 - JAVA架构师](JAVA架构师.md)
- [第二章 - python全栈](python全栈.md)
- [第三章 – GO编程](GO编程.md)
- [第四章 – 大数据](大数据.md)
- [第五章 – AI智能](AI智能.md)
- [第六章 – 云原生](云原生.md)
- [第七章 – 物联网](物联网.md)
- [第八章 - 云计算](云计算.md)
- [第九章 - 区块链](区块链.md)
- [第十章 - 运维工程师](运维工程师.md)
- [第十一章 - 元宇宙](元宇宙.md)
- [第十二章 - WEB3.0](WEB3.0.md)
------

\## 一、jvm的生命周期

**jvm的生命周期**： JVM是Java的核心和基础，用来加载字节码(.class)文件、管理并分配内存、执行垃圾收集。JVM的生命周期分为七个阶段：

**1. 创建阶段**

\* 1.为对象分配内存空间。

\* 2.开始构造对象。

\* 3.递归调用其父类的构造函数。

\* 4.进行对象实例初始化与变量初始化。

**2. 强引用**

基本上我们使用的都是强引用，除非我们显示的使用软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)。强引用即使不使用了，GC也不会回收它。当空间不足，Java宁愿抛出OutOfMemoryError错误，是程序终止也不回收。

**2.软引用**

具有较强的引用功能。只有当内存不够的时候，才回收这类内存，因此在内存足够的时候，他们通常不被收回。他可以用于实现一些常用资源的缓存，实现cache的功能，保证最大限度的使用内存而不引起OutOfMemory。

**3.弱引用**

弱引用的对象拥有更短暂的生命周期。不管内存空间是否足够，一但发现弱引用就会被回收。

**4. 虚引用**

虚引用的用途较少，主要用于辅助finalize函数的使用。Phantom对象指一些执行完了finalize函数，并且为不可达对象，但是还没有被GC回收的对象。这种对象可以辅助finalize进行一些后期的回收工作，我们通过覆盖Reference的clear()方法，增强资源回收机制的灵活性。虚引用主要适用于以某种比java终结机制更灵活的方式调度pre-mortem清除操作。

**4. 不可视阶段**

当一个对象处于不可视阶段，说明我们在其他区域的代码中已经不可以再引用它，其引用已经消失，例如：本地变量超出了其可视范围。

**5. 不可达阶段**

处于不可达阶段的对象在虚拟机的对象引用根集合中再也找不到直接或间接的强引用，这些对象一般是所有线程栈中的临时变量，所有已装载的类的静态变量或者是对本地代码接口(JNI)的引用。

**6. 可收集阶段**

**7. 终结阶段**

**8. 释放阶段**

对象可能处于下面三种情况则说明对象处于可收集阶段、终结阶段、释放阶段：

1.回收器发现该对象已不可到达。

2.finalize方法已经被执行。

3.对象空间已被重用。

**JVM实例的诞生**

 当一个程序启动，伴随的就是一个jvm实例的诞生，当这个程序关闭退出，这个jvm实例就随之消亡。如果在同一台机器上运行多个程序，将诞生相应数量的jvm实例，每个程序都有一个与之对应的jvm实例供其运行。任何一个拥有公开的（public）、静态的（static）、没有返回值（void）并且接受一个字符串数组参数（String[] args） 的main()函数的class都可以作为JVM实例运行的起点 。

**JVM实例的运行**

 main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。java程序的初始线程 只就是运行main（）的线程，这个线程是非守护线程，只要还有任何非守护线程还在运行，那么jvm就存活着。

**JVM实例的消亡**

当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用java.lang.Runtime类或者java.lang.System.exit()来退出。

\## 二、JAVA类生命周期

当我们编写一个java的源文件后，经过编译会生成一个后缀名为class的文件，这种文件叫做字节码文件，只有这种字节码文件才能够在java虚拟机中运行，java类的生命周期就是指一个class文件从加载到卸载的全过程。

**JAVA类完整生命周期五个阶段: 加载 > 链接 > 初始化 > 使用 > 卸载**

![2429fd88efc2eb7d50afc5f337331054.jpeg](evernotecid://4442075D-3FB8-4B29-9EEF-FD6CFA3F4236/appyinxiangcom/34731717/ENResource/p1)

**通过Java命令执行代码的大体流程：**

![9c10cdf2fd37dc8c166b83495760a062.jpeg](evernotecid://4442075D-3FB8-4B29-9EEF-FD6CFA3F4236/appyinxiangcom/34731717/ENResource/p5)

\* **1，加载**：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。

\* **2，验证**：校验字节码文件的正确性，当一个类被加载之后，必须要验证一下这个类是否合法，比如这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。总之，这个阶段的目的就是保证加载的类是能够被jvm所运行。

\* **3，准备**：给类的静态变量分配内存，并赋予默认值；准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值，对于非静态的变量，则不会为它们分配内存。有一点需要注意，这时候，静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。jvm默认的初值是这样的：

\```

\1. 基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0。

\2. 引用类型的默认值为null。

\3. 常量的默认值为我们程序中设定的值，比如我们在程序中定义final static int a = 100，则准备阶段中a的初值就是100。

\```

\* **4，解析**：将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用；在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。

\* **5，初始化**：对类的静态变量初始化为指定的值，执行静态代码块；

连接阶段完成之后会根据使用的情况（直接引用还是被动引用）来选择是否对类进行初始化。

如果一个类被直接引用，就会触发类的初始化。在java中，直接引用的情况有：

\```

通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法；

通过反射方式执行以上三种行为；

初始化子类的时候，会触发父类的初始化；

作为程序入口直接运行时（也就是直接调用main方法）。

除了以上四种情况，其他使用类的方式叫做被动引用，而被动引用不会触发类的初始化。

\```

![04577ecdfe7ff5b3f93e40476405b897.jpeg](evernotecid://4442075D-3FB8-4B29-9EEF-FD6CFA3F4236/appyinxiangcom/34731717/ENResource/p2)

类被加载到方法区中后主要包含：

运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用等信息。

类加载器的引用：这个类到类加载器实例的引用

对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。

**注意**：主类在运行过程中如果使用到其它类，会逐步加载这些类。jar包或war包里的类不是一次性全部加载的，是使用到时才加载。

类的初始化过程是这样的：按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句。 在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。

**6，使用**：类的使用包括主动引用和被动引用，主动引用在上面的初始化章节中已经说过了，下面我们主要来说一下被动引用：

引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。

定义类数组，不会引起类的初始化。

引用类的常量，不会引起类的初始化。

使用阶段包括主动引用和被动引用，主动饮用会引起类的初始化，而被动引用不会引起类的初始化。当使用阶段完成之后，java类就进入了卸载阶段。

**7，卸载**：三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。

该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例；

加载该类的ClassLoader已经被回收；

该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

\## 三、类加载时机

\1. 创建类的实例，也就是new一个对象

\2. 访问某个类或接口的静态变量，或者对该静态变量赋值

\3. 调用类的静态方法

\4. 反射（Class.forName("com.lyj.load")）

\5. 初始化一个类的子类（会首先初始化子类的父类）

\6. JVM启动时标明的启动类，即文件名和类名相同的那个类  

\7. 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。

8.

\## 四、类加载器

类加载过程主要是通过类加载器来实现的，JVM预定义有4种类加载器，当一个JVM启动的时候，Java开始使用如下三种类加载器：

\1. 引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等

\2. 扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包

\3. 应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类

\4. 自定义加载器：负责加载用户自定义路径下的类包

\## 五、类加载机制

1.JVM的类加载机制主要有如下3种：

\* 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。

\* 双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。

\* 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。

2.双亲委派机制：

**双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载**

![435430bf62509a96566c8d2e20349880.png](evernotecid://4442075D-3FB8-4B29-9EEF-FD6CFA3F4236/appyinxiangcom/34731717/ENResource/p3)

![28599a55bdc21f05f0095164a19033b7.jpeg](evernotecid://4442075D-3FB8-4B29-9EEF-FD6CFA3F4236/appyinxiangcom/34731717/ENResource/p4)

\* 双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。

\* 双亲委派机制的优势：

采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。

其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

**为什么要设计双亲委派机制？**

沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改

避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性
